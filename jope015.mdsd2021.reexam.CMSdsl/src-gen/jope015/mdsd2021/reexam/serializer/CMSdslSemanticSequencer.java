/*
 * generated by Xtext 2.22.0
 */
package jope015.mdsd2021.reexam.serializer;

import com.google.inject.Inject;
import java.util.Set;
import jope015.mdsd2021.reexam.cMSdsl.And;
import jope015.mdsd2021.reexam.cMSdsl.BelongsTo;
import jope015.mdsd2021.reexam.cMSdsl.BelongsToMany;
import jope015.mdsd2021.reexam.cMSdsl.Bool;
import jope015.mdsd2021.reexam.cMSdsl.CMSdslPackage;
import jope015.mdsd2021.reexam.cMSdsl.CheckBlock;
import jope015.mdsd2021.reexam.cMSdsl.Comparison;
import jope015.mdsd2021.reexam.cMSdsl.DBConfig;
import jope015.mdsd2021.reexam.cMSdsl.Def;
import jope015.mdsd2021.reexam.cMSdsl.Dialect;
import jope015.mdsd2021.reexam.cMSdsl.Div;
import jope015.mdsd2021.reexam.cMSdsl.Dt;
import jope015.mdsd2021.reexam.cMSdsl.Entity;
import jope015.mdsd2021.reexam.cMSdsl.Equality;
import jope015.mdsd2021.reexam.cMSdsl.Err;
import jope015.mdsd2021.reexam.cMSdsl.Eval;
import jope015.mdsd2021.reexam.cMSdsl.Field;
import jope015.mdsd2021.reexam.cMSdsl.Flt;
import jope015.mdsd2021.reexam.cMSdsl.HasMany;
import jope015.mdsd2021.reexam.cMSdsl.HasOne;
import jope015.mdsd2021.reexam.cMSdsl.Host;
import jope015.mdsd2021.reexam.cMSdsl.InpDate;
import jope015.mdsd2021.reexam.cMSdsl.InpMail;
import jope015.mdsd2021.reexam.cMSdsl.InpNum;
import jope015.mdsd2021.reexam.cMSdsl.InpPass;
import jope015.mdsd2021.reexam.cMSdsl.InpText;
import jope015.mdsd2021.reexam.cMSdsl.InpTextArea;
import jope015.mdsd2021.reexam.cMSdsl.InputField;
import jope015.mdsd2021.reexam.cMSdsl.Integ;
import jope015.mdsd2021.reexam.cMSdsl.Lib;
import jope015.mdsd2021.reexam.cMSdsl.Lng;
import jope015.mdsd2021.reexam.cMSdsl.Minus;
import jope015.mdsd2021.reexam.cMSdsl.Mul;
import jope015.mdsd2021.reexam.cMSdsl.Num;
import jope015.mdsd2021.reexam.cMSdsl.Or;
import jope015.mdsd2021.reexam.cMSdsl.ParamOrArgUse;
import jope015.mdsd2021.reexam.cMSdsl.Pass;
import jope015.mdsd2021.reexam.cMSdsl.Plus;
import jope015.mdsd2021.reexam.cMSdsl.Port;
import jope015.mdsd2021.reexam.cMSdsl.Project;
import jope015.mdsd2021.reexam.cMSdsl.PropTest;
import jope015.mdsd2021.reexam.cMSdsl.Relationship;
import jope015.mdsd2021.reexam.cMSdsl.Str;
import jope015.mdsd2021.reexam.cMSdsl.Succ;
import jope015.mdsd2021.reexam.cMSdsl.User;
import jope015.mdsd2021.reexam.cMSdsl.ValidationCheck;
import jope015.mdsd2021.reexam.cMSdsl.Validator;
import jope015.mdsd2021.reexam.cMSdsl.ValidatorUse;
import jope015.mdsd2021.reexam.cMSdsl.Warn;
import jope015.mdsd2021.reexam.services.CMSdslGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CMSdslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CMSdslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CMSdslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CMSdslPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case CMSdslPackage.BELONGS_TO:
				sequence_RelationshipType(context, (BelongsTo) semanticObject); 
				return; 
			case CMSdslPackage.BELONGS_TO_MANY:
				sequence_RelationshipType(context, (BelongsToMany) semanticObject); 
				return; 
			case CMSdslPackage.BOOL:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusMinusRule()
						|| action == grammarAccess.getPlusMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusMinusAccess().getMinusLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMulDivRule()
						|| action == grammarAccess.getMulDivAccess().getMulLeftAction_1_0_0_0()
						|| action == grammarAccess.getMulDivAccess().getDivLeftAction_1_0_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (Bool) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDataTypeRule()) {
					sequence_DataType(context, (Bool) semanticObject); 
					return; 
				}
				else break;
			case CMSdslPackage.CHECK_BLOCK:
				sequence_CheckBlock(context, (CheckBlock) semanticObject); 
				return; 
			case CMSdslPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case CMSdslPackage.DB_CONFIG:
				sequence_DBConfig(context, (DBConfig) semanticObject); 
				return; 
			case CMSdslPackage.DEF:
				sequence_FieldProp(context, (Def) semanticObject); 
				return; 
			case CMSdslPackage.DIALECT:
				sequence_DBDecl(context, (Dialect) semanticObject); 
				return; 
			case CMSdslPackage.DIV:
				sequence_MulDiv(context, (Div) semanticObject); 
				return; 
			case CMSdslPackage.DT:
				sequence_DataType(context, (Dt) semanticObject); 
				return; 
			case CMSdslPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case CMSdslPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case CMSdslPackage.ERR:
				sequence_ValidationStatus(context, (Err) semanticObject); 
				return; 
			case CMSdslPackage.EVAL:
				sequence_Eval(context, (Eval) semanticObject); 
				return; 
			case CMSdslPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case CMSdslPackage.FLT:
				sequence_DataType(context, (Flt) semanticObject); 
				return; 
			case CMSdslPackage.HAS_MANY:
				sequence_RelationshipType(context, (HasMany) semanticObject); 
				return; 
			case CMSdslPackage.HAS_ONE:
				sequence_RelationshipType(context, (HasOne) semanticObject); 
				return; 
			case CMSdslPackage.HOST:
				sequence_DBDecl(context, (Host) semanticObject); 
				return; 
			case CMSdslPackage.INP_DATE:
				sequence_InputType(context, (InpDate) semanticObject); 
				return; 
			case CMSdslPackage.INP_MAIL:
				sequence_InputType(context, (InpMail) semanticObject); 
				return; 
			case CMSdslPackage.INP_NUM:
				sequence_InputType(context, (InpNum) semanticObject); 
				return; 
			case CMSdslPackage.INP_PASS:
				sequence_InputType(context, (InpPass) semanticObject); 
				return; 
			case CMSdslPackage.INP_TEXT:
				sequence_InputType(context, (InpText) semanticObject); 
				return; 
			case CMSdslPackage.INP_TEXT_AREA:
				sequence_InputType(context, (InpTextArea) semanticObject); 
				return; 
			case CMSdslPackage.INPUT_FIELD:
				sequence_FieldProp(context, (InputField) semanticObject); 
				return; 
			case CMSdslPackage.INTEG:
				sequence_DataType(context, (Integ) semanticObject); 
				return; 
			case CMSdslPackage.LIB:
				sequence_DBDecl(context, (Lib) semanticObject); 
				return; 
			case CMSdslPackage.LNG:
				sequence_DataType(context, (Lng) semanticObject); 
				return; 
			case CMSdslPackage.MINUS:
				sequence_PlusMinus(context, (Minus) semanticObject); 
				return; 
			case CMSdslPackage.MUL:
				sequence_MulDiv(context, (Mul) semanticObject); 
				return; 
			case CMSdslPackage.NUM:
				sequence_Atomic(context, (Num) semanticObject); 
				return; 
			case CMSdslPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case CMSdslPackage.PARAM_OR_ARG_USE:
				sequence_ParamOrArgUse(context, (ParamOrArgUse) semanticObject); 
				return; 
			case CMSdslPackage.PARAMETER:
				sequence_Parameter(context, (jope015.mdsd2021.reexam.cMSdsl.Parameter) semanticObject); 
				return; 
			case CMSdslPackage.PASS:
				sequence_DBDecl(context, (Pass) semanticObject); 
				return; 
			case CMSdslPackage.PLUS:
				sequence_PlusMinus(context, (Plus) semanticObject); 
				return; 
			case CMSdslPackage.PORT:
				sequence_DBDecl(context, (Port) semanticObject); 
				return; 
			case CMSdslPackage.PROJECT:
				sequence_Project(context, (Project) semanticObject); 
				return; 
			case CMSdslPackage.PROP_TEST:
				sequence_FieldProp(context, (PropTest) semanticObject); 
				return; 
			case CMSdslPackage.RELATIONSHIP:
				sequence_Relationship(context, (Relationship) semanticObject); 
				return; 
			case CMSdslPackage.STR:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getPlusMinusRule()
						|| action == grammarAccess.getPlusMinusAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getPlusMinusAccess().getMinusLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMulDivRule()
						|| action == grammarAccess.getMulDivAccess().getMulLeftAction_1_0_0_0()
						|| action == grammarAccess.getMulDivAccess().getDivLeftAction_1_0_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (Str) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDataTypeRule()) {
					sequence_DataType(context, (Str) semanticObject); 
					return; 
				}
				else break;
			case CMSdslPackage.SUCC:
				sequence_ValidationStatus(context, (Succ) semanticObject); 
				return; 
			case CMSdslPackage.USER:
				sequence_DBDecl(context, (User) semanticObject); 
				return; 
			case CMSdslPackage.VALIDATION_CHECK:
				sequence_ValidationCheck(context, (ValidationCheck) semanticObject); 
				return; 
			case CMSdslPackage.VALIDATOR:
				sequence_Validator(context, (Validator) semanticObject); 
				return; 
			case CMSdslPackage.VALIDATOR_USE:
				sequence_ValidatorUse(context, (ValidatorUse) semanticObject); 
				return; 
			case CMSdslPackage.WARN:
				sequence_ValidationStatus(context, (Warn) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.Comparison_1_0 returns And
	 *     PlusMinus returns And
	 *     PlusMinus.Plus_1_0_0_0 returns And
	 *     PlusMinus.Minus_1_0_1_0 returns And
	 *     MulDiv returns And
	 *     MulDiv.Mul_1_0_0_0 returns And
	 *     MulDiv.Div_1_0_1_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Bool
	 *     Or returns Bool
	 *     Or.Or_1_0 returns Bool
	 *     And returns Bool
	 *     And.And_1_0 returns Bool
	 *     Equality returns Bool
	 *     Equality.Equality_1_0 returns Bool
	 *     Comparison returns Bool
	 *     Comparison.Comparison_1_0 returns Bool
	 *     PlusMinus returns Bool
	 *     PlusMinus.Plus_1_0_0_0 returns Bool
	 *     PlusMinus.Minus_1_0_1_0 returns Bool
	 *     MulDiv returns Bool
	 *     MulDiv.Mul_1_0_0_0 returns Bool
	 *     MulDiv.Div_1_0_1_0 returns Bool
	 *     Primary returns Bool
	 *     Atomic returns Bool
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_Atomic(ISerializationContext context, Bool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Num
	 *     Or returns Num
	 *     Or.Or_1_0 returns Num
	 *     And returns Num
	 *     And.And_1_0 returns Num
	 *     Equality returns Num
	 *     Equality.Equality_1_0 returns Num
	 *     Comparison returns Num
	 *     Comparison.Comparison_1_0 returns Num
	 *     PlusMinus returns Num
	 *     PlusMinus.Plus_1_0_0_0 returns Num
	 *     PlusMinus.Minus_1_0_1_0 returns Num
	 *     MulDiv returns Num
	 *     MulDiv.Mul_1_0_0_0 returns Num
	 *     MulDiv.Div_1_0_1_0 returns Num
	 *     Primary returns Num
	 *     Atomic returns Num
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Atomic(ISerializationContext context, Num semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.NUM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.NUM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Str
	 *     Or returns Str
	 *     Or.Or_1_0 returns Str
	 *     And returns Str
	 *     And.And_1_0 returns Str
	 *     Equality returns Str
	 *     Equality.Equality_1_0 returns Str
	 *     Comparison returns Str
	 *     Comparison.Comparison_1_0 returns Str
	 *     PlusMinus returns Str
	 *     PlusMinus.Plus_1_0_0_0 returns Str
	 *     PlusMinus.Minus_1_0_1_0 returns Str
	 *     MulDiv returns Str
	 *     MulDiv.Mul_1_0_0_0 returns Str
	 *     MulDiv.Div_1_0_1_0 returns Str
	 *     Primary returns Str
	 *     Atomic returns Str
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, Str semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.STR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.STR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CheckBlock returns CheckBlock
	 *
	 * Constraint:
	 *     (validator=ValidatorUse statusCond+=ValidationStatus*)
	 */
	protected void sequence_CheckBlock(ISerializationContext context, CheckBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *     PlusMinus returns Comparison
	 *     PlusMinus.Plus_1_0_0_0 returns Comparison
	 *     PlusMinus.Minus_1_0_1_0 returns Comparison
	 *     MulDiv returns Comparison
	 *     MulDiv.Mul_1_0_0_0 returns Comparison
	 *     MulDiv.Div_1_0_1_0 returns Comparison
	 *     Primary returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 (op='>=' | op='<=' | op='>' | op='<') right=PlusMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryElement returns DBConfig
	 *     DBConfig returns DBConfig
	 *
	 * Constraint:
	 *     (type='database' config+=DBDecl*)
	 */
	protected void sequence_DBConfig(ISerializationContext context, DBConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DBDecl returns Dialect
	 *
	 * Constraint:
	 *     (type='dialect' value=STRING)
	 */
	protected void sequence_DBDecl(ISerializationContext context, Dialect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DB_DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DB_DECL__TYPE));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DIALECT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DIALECT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDBDeclAccess().getTypeDialectKeyword_3_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getDBDeclAccess().getValueSTRINGTerminalRuleCall_3_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DBDecl returns Host
	 *
	 * Constraint:
	 *     (type='hostname' value=STRING)
	 */
	protected void sequence_DBDecl(ISerializationContext context, Host semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DB_DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DB_DECL__TYPE));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.HOST__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.HOST__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDBDeclAccess().getTypeHostnameKeyword_1_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getDBDeclAccess().getValueSTRINGTerminalRuleCall_1_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DBDecl returns Lib
	 *
	 * Constraint:
	 *     (type='library' value=STRING)
	 */
	protected void sequence_DBDecl(ISerializationContext context, Lib semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DB_DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DB_DECL__TYPE));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.LIB__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.LIB__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDBDeclAccess().getTypeLibraryKeyword_0_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getDBDeclAccess().getValueSTRINGTerminalRuleCall_0_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DBDecl returns Pass
	 *
	 * Constraint:
	 *     (type='password' value=STRING)
	 */
	protected void sequence_DBDecl(ISerializationContext context, Pass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DB_DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DB_DECL__TYPE));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.PASS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.PASS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDBDeclAccess().getTypePasswordKeyword_5_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getDBDeclAccess().getValueSTRINGTerminalRuleCall_5_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DBDecl returns Port
	 *
	 * Constraint:
	 *     (type='port' value=INT)
	 */
	protected void sequence_DBDecl(ISerializationContext context, Port semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DB_DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DB_DECL__TYPE));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.PORT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.PORT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDBDeclAccess().getTypePortKeyword_2_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getDBDeclAccess().getValueINTTerminalRuleCall_2_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DBDecl returns User
	 *
	 * Constraint:
	 *     (type='username' value=STRING)
	 */
	protected void sequence_DBDecl(ISerializationContext context, User semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DB_DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DB_DECL__TYPE));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.USER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.USER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDBDeclAccess().getTypeUsernameKeyword_4_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getDBDeclAccess().getValueSTRINGTerminalRuleCall_4_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns Bool
	 *
	 * Constraint:
	 *     type='bool'
	 */
	protected void sequence_DataType(ISerializationContext context, Bool semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DATA_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DATA_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataTypeAccess().getTypeBoolKeyword_4_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns Dt
	 *
	 * Constraint:
	 *     type='date'
	 */
	protected void sequence_DataType(ISerializationContext context, Dt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DATA_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DATA_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataTypeAccess().getTypeDateKeyword_1_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns Flt
	 *
	 * Constraint:
	 *     type='float'
	 */
	protected void sequence_DataType(ISerializationContext context, Flt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DATA_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DATA_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataTypeAccess().getTypeFloatKeyword_5_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns Integ
	 *
	 * Constraint:
	 *     type='int'
	 */
	protected void sequence_DataType(ISerializationContext context, Integ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DATA_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DATA_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataTypeAccess().getTypeIntKeyword_2_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns Lng
	 *
	 * Constraint:
	 *     type='long'
	 */
	protected void sequence_DataType(ISerializationContext context, Lng semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DATA_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DATA_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataTypeAccess().getTypeLongKeyword_3_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns Str
	 *
	 * Constraint:
	 *     type='string'
	 */
	protected void sequence_DataType(ISerializationContext context, Str semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DATA_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DATA_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataTypeAccess().getTypeStringKeyword_0_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryElement returns Entity
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (name=ID (relations+=Relationship relations+=Relationship*)? members+=EntityDecl*)
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.Comparison_1_0 returns Equality
	 *     PlusMinus returns Equality
	 *     PlusMinus.Plus_1_0_0_0 returns Equality
	 *     PlusMinus.Minus_1_0_1_0 returns Equality
	 *     MulDiv returns Equality
	 *     MulDiv.Mul_1_0_0_0 returns Equality
	 *     MulDiv.Div_1_0_1_0 returns Equality
	 *     Primary returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 (op='==' | op='!=') right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryElement returns Eval
	 *     Eval returns Eval
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Eval(ISerializationContext context, Eval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.EVAL__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.EVAL__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEvalAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FieldProp returns Def
	 *
	 * Constraint:
	 *     (type='default' value=STRING)
	 */
	protected void sequence_FieldProp(ISerializationContext context, Def semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.FIELD_PROP__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.FIELD_PROP__TYPE));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DEF__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DEF__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldPropAccess().getTypeDefaultKeyword_0_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFieldPropAccess().getValueSTRINGTerminalRuleCall_0_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FieldProp returns InputField
	 *
	 * Constraint:
	 *     (type='inputType' value=InputType)
	 */
	protected void sequence_FieldProp(ISerializationContext context, InputField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.FIELD_PROP__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.FIELD_PROP__TYPE));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.INPUT_FIELD__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.INPUT_FIELD__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldPropAccess().getTypeInputTypeKeyword_2_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFieldPropAccess().getValueInputTypeParserRuleCall_2_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FieldProp returns PropTest
	 *
	 * Constraint:
	 *     (type='test' value=STRING)
	 */
	protected void sequence_FieldProp(ISerializationContext context, PropTest semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.FIELD_PROP__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.FIELD_PROP__TYPE));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.PROP_TEST__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.PROP_TEST__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldPropAccess().getTypeTestKeyword_1_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFieldPropAccess().getValueSTRINGTerminalRuleCall_1_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntityDecl returns Field
	 *     Field returns Field
	 *     ParamOrArg returns Field
	 *
	 * Constraint:
	 *     (dontShow?='hide'? name=ID type=DataType properties+=FieldProp*)
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputType returns InpDate
	 *
	 * Constraint:
	 *     type='date'
	 */
	protected void sequence_InputType(ISerializationContext context, InpDate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.INPUT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.INPUT_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputTypeAccess().getTypeDateKeyword_1_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputType returns InpMail
	 *
	 * Constraint:
	 *     type='email'
	 */
	protected void sequence_InputType(ISerializationContext context, InpMail semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.INPUT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.INPUT_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputTypeAccess().getTypeEmailKeyword_0_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputType returns InpNum
	 *
	 * Constraint:
	 *     type='number'
	 */
	protected void sequence_InputType(ISerializationContext context, InpNum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.INPUT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.INPUT_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputTypeAccess().getTypeNumberKeyword_2_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputType returns InpPass
	 *
	 * Constraint:
	 *     type='password'
	 */
	protected void sequence_InputType(ISerializationContext context, InpPass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.INPUT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.INPUT_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputTypeAccess().getTypePasswordKeyword_3_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputType returns InpText
	 *
	 * Constraint:
	 *     type='text'
	 */
	protected void sequence_InputType(ISerializationContext context, InpText semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.INPUT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.INPUT_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputTypeAccess().getTypeTextKeyword_4_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputType returns InpTextArea
	 *
	 * Constraint:
	 *     type='textarea'
	 */
	protected void sequence_InputType(ISerializationContext context, InpTextArea semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.INPUT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.INPUT_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputTypeAccess().getTypeTextareaKeyword_5_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Div
	 *     Or returns Div
	 *     Or.Or_1_0 returns Div
	 *     And returns Div
	 *     And.And_1_0 returns Div
	 *     Equality returns Div
	 *     Equality.Equality_1_0 returns Div
	 *     Comparison returns Div
	 *     Comparison.Comparison_1_0 returns Div
	 *     PlusMinus returns Div
	 *     PlusMinus.Plus_1_0_0_0 returns Div
	 *     PlusMinus.Minus_1_0_1_0 returns Div
	 *     MulDiv returns Div
	 *     MulDiv.Mul_1_0_0_0 returns Div
	 *     MulDiv.Div_1_0_1_0 returns Div
	 *     Primary returns Div
	 *
	 * Constraint:
	 *     (left=MulDiv_Div_1_0_1_0 right=Primary)
	 */
	protected void sequence_MulDiv(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulDivAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulDivAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Mul
	 *     Or returns Mul
	 *     Or.Or_1_0 returns Mul
	 *     And returns Mul
	 *     And.And_1_0 returns Mul
	 *     Equality returns Mul
	 *     Equality.Equality_1_0 returns Mul
	 *     Comparison returns Mul
	 *     Comparison.Comparison_1_0 returns Mul
	 *     PlusMinus returns Mul
	 *     PlusMinus.Plus_1_0_0_0 returns Mul
	 *     PlusMinus.Minus_1_0_1_0 returns Mul
	 *     MulDiv returns Mul
	 *     MulDiv.Mul_1_0_0_0 returns Mul
	 *     MulDiv.Div_1_0_1_0 returns Mul
	 *     Primary returns Mul
	 *
	 * Constraint:
	 *     (left=MulDiv_Mul_1_0_0_0 right=Primary)
	 */
	protected void sequence_MulDiv(ISerializationContext context, Mul semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.MUL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.MUL__LEFT));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.MUL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.MUL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulDivAccess().getMulLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulDivAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.Comparison_1_0 returns Or
	 *     PlusMinus returns Or
	 *     PlusMinus.Plus_1_0_0_0 returns Or
	 *     PlusMinus.Minus_1_0_1_0 returns Or
	 *     MulDiv returns Or
	 *     MulDiv.Mul_1_0_0_0 returns Or
	 *     MulDiv.Div_1_0_1_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParamOrArgUse returns ParamOrArgUse
	 *     Expression returns ParamOrArgUse
	 *     Or returns ParamOrArgUse
	 *     Or.Or_1_0 returns ParamOrArgUse
	 *     And returns ParamOrArgUse
	 *     And.And_1_0 returns ParamOrArgUse
	 *     Equality returns ParamOrArgUse
	 *     Equality.Equality_1_0 returns ParamOrArgUse
	 *     Comparison returns ParamOrArgUse
	 *     Comparison.Comparison_1_0 returns ParamOrArgUse
	 *     PlusMinus returns ParamOrArgUse
	 *     PlusMinus.Plus_1_0_0_0 returns ParamOrArgUse
	 *     PlusMinus.Minus_1_0_1_0 returns ParamOrArgUse
	 *     MulDiv returns ParamOrArgUse
	 *     MulDiv.Mul_1_0_0_0 returns ParamOrArgUse
	 *     MulDiv.Div_1_0_1_0 returns ParamOrArgUse
	 *     Primary returns ParamOrArgUse
	 *     Atomic returns ParamOrArgUse
	 *
	 * Constraint:
	 *     ref=[ParamOrArg|ID]
	 */
	protected void sequence_ParamOrArgUse(ISerializationContext context, ParamOrArgUse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.PARAM_OR_ARG_USE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.PARAM_OR_ARG_USE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamOrArgUseAccess().getRefParamOrArgIDTerminalRuleCall_0_1(), semanticObject.eGet(CMSdslPackage.Literals.PARAM_OR_ARG_USE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *     ParamOrArg returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=DataType)
	 */
	protected void sequence_Parameter(ISerializationContext context, jope015.mdsd2021.reexam.cMSdsl.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.PARAM_OR_ARG__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.PARAM_OR_ARG__NAME));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.PARAM_OR_ARG__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.PARAM_OR_ARG__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeDataTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0 returns Minus
	 *     PlusMinus returns Minus
	 *     PlusMinus.Plus_1_0_0_0 returns Minus
	 *     PlusMinus.Minus_1_0_1_0 returns Minus
	 *     MulDiv returns Minus
	 *     MulDiv.Mul_1_0_0_0 returns Minus
	 *     MulDiv.Div_1_0_1_0 returns Minus
	 *     Primary returns Minus
	 *
	 * Constraint:
	 *     (left=PlusMinus_Minus_1_0_1_0 right=MulDiv)
	 */
	protected void sequence_PlusMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusMinusAccess().getRightMulDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0 returns Plus
	 *     PlusMinus returns Plus
	 *     PlusMinus.Plus_1_0_0_0 returns Plus
	 *     PlusMinus.Minus_1_0_1_0 returns Plus
	 *     MulDiv returns Plus
	 *     MulDiv.Mul_1_0_0_0 returns Plus
	 *     MulDiv.Div_1_0_1_0 returns Plus
	 *     Primary returns Plus
	 *
	 * Constraint:
	 *     (left=PlusMinus_Plus_1_0_0_0 right=MulDiv)
	 */
	protected void sequence_PlusMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusMinusAccess().getRightMulDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Project returns Project
	 *
	 * Constraint:
	 *     (name=ID elements+=PrimaryElement*)
	 */
	protected void sequence_Project(ISerializationContext context, Project semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns BelongsTo
	 *
	 * Constraint:
	 *     {BelongsTo}
	 */
	protected void sequence_RelationshipType(ISerializationContext context, BelongsTo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns BelongsToMany
	 *
	 * Constraint:
	 *     {BelongsToMany}
	 */
	protected void sequence_RelationshipType(ISerializationContext context, BelongsToMany semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns HasMany
	 *
	 * Constraint:
	 *     {HasMany}
	 */
	protected void sequence_RelationshipType(ISerializationContext context, HasMany semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipType returns HasOne
	 *
	 * Constraint:
	 *     {HasOne}
	 */
	protected void sequence_RelationshipType(ISerializationContext context, HasOne semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Relationship returns Relationship
	 *
	 * Constraint:
	 *     (relationType=RelationshipType entity=[Entity|ID])
	 */
	protected void sequence_Relationship(ISerializationContext context, Relationship semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.RELATIONSHIP__RELATION_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.RELATIONSHIP__RELATION_TYPE));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.RELATIONSHIP__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.RELATIONSHIP__ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationshipAccess().getRelationTypeRelationshipTypeParserRuleCall_0_0(), semanticObject.getRelationType());
		feeder.accept(grammarAccess.getRelationshipAccess().getEntityEntityIDTerminalRuleCall_1_0_1(), semanticObject.eGet(CMSdslPackage.Literals.RELATIONSHIP__ENTITY, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntityDecl returns ValidationCheck
	 *     ValidationCheck returns ValidationCheck
	 *
	 * Constraint:
	 *     (validator=ValidatorUse errrorMsg=STRING)
	 */
	protected void sequence_ValidationCheck(ISerializationContext context, ValidationCheck semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.VALIDATION_CHECK__VALIDATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.VALIDATION_CHECK__VALIDATOR));
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.VALIDATION_CHECK__ERRROR_MSG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.VALIDATION_CHECK__ERRROR_MSG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValidationCheckAccess().getValidatorValidatorUseParserRuleCall_1_0(), semanticObject.getValidator());
		feeder.accept(grammarAccess.getValidationCheckAccess().getErrrorMsgSTRINGTerminalRuleCall_3_0(), semanticObject.getErrrorMsg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ValidationStatus returns Err
	 *
	 * Constraint:
	 *     msg=STRING
	 */
	protected void sequence_ValidationStatus(ISerializationContext context, Err semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.VALIDATION_STATUS__MSG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.VALIDATION_STATUS__MSG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValidationStatusAccess().getMsgSTRINGTerminalRuleCall_0_3_0(), semanticObject.getMsg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ValidationStatus returns Succ
	 *
	 * Constraint:
	 *     msg=STRING
	 */
	protected void sequence_ValidationStatus(ISerializationContext context, Succ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.VALIDATION_STATUS__MSG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.VALIDATION_STATUS__MSG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValidationStatusAccess().getMsgSTRINGTerminalRuleCall_2_3_0(), semanticObject.getMsg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ValidationStatus returns Warn
	 *
	 * Constraint:
	 *     msg=STRING
	 */
	protected void sequence_ValidationStatus(ISerializationContext context, Warn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CMSdslPackage.Literals.VALIDATION_STATUS__MSG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CMSdslPackage.Literals.VALIDATION_STATUS__MSG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValidationStatusAccess().getMsgSTRINGTerminalRuleCall_1_3_0(), semanticObject.getMsg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ValidatorUse returns ValidatorUse
	 *
	 * Constraint:
	 *     (validator=[Validator|ID] args+=[Field|ID] args+=[Field|ID]*)
	 */
	protected void sequence_ValidatorUse(ISerializationContext context, ValidatorUse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryElement returns Validator
	 *     Validator returns Validator
	 *
	 * Constraint:
	 *     (name=ID params+=Parameter params+=Parameter* comparison=Expression)
	 */
	protected void sequence_Validator(ISerializationContext context, Validator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
